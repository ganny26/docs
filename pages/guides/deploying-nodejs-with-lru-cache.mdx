import Guide from '~/components/layout/guide'
import { TerminalInput } from '~/components/text/terminal'
import Card from '~/components/card'

export const meta = {
  title: 'How to deploy a serverless Node.js application that uses a LRU cache',
  description:
    'How to deploy a serverless Node.js application that uses a LRU cache',
  published: '2019-03-02T13:48:47.143Z',
  authors: ['ganny26'],
  url: '/guides/deploying-nodejs-with-lru-cache'
}

In this guide, we will cover how to set up a Node LRU Cache with Express JS App and how to deploy it with [ZEIT Now](/docs/v2).

# Preface

First of all, what is a cache? A cache is a place where frequently-accessed data is stored that can be quickly retrieved with little overhead. Cache is useful when you have a database-driven website that gets high amounts of traffic as it can help reduce the load on your database server by bypassing it completely to retrieve certain data.

When data is requested, your code first checks to see if it exists in your cache. If the requested data does not exist in the cache, it will then get the data from the database. A copy of the data is then placed in the cache so it will be available the next time it is requested. The copy will sometimes have a [TTL](https://en.wikipedia.org/wiki/Time_to_live) or (time to live) expiration time. This ensures that data in the cache does not get outdated as updates are made to the original record in the database.

LRU cache stands for "least recently used" cache. This puts a limit on the amount of items you store in the cache your server does not run out of memory as more and more items are stored in the cache. As the limit of items is reached, the LRU cache will start to remove the "least recently used" items in the cache.

## Step 1: Installing The LRU Cache Node Module and Express

<TerminalInput>yarn add lru-cache yarn add express</TerminalInput>

## Step 2: Importing the Module

```js
const LRU = require('lru-cache')

const options = {
  max: 5, // The maximum number of items allowed in the cache
  maxAge: 15000 // The maximum life of a cached item in milliseconds
}

const cache = new LRU(options)
```

For the purpose of demonstration, the application only sets a maximum of 5 items to be in the cache at any given time and each item can only stay in the cache for 15 seconds.

## Step 3: Storing and Retrieving Data

Now you can start using the cache to store and retrieve data. Now, create a reusable function so you don't have to write the logic every time you request data.

```js
function getData(key) {
  //Check if data is in the cache
  var data = cache.get(key)

  //When key is not present in cache data is undefined then fetch it again
  if (!data) {
    //Get a random user and set it to cache
    getRandomUser().then(user => {
      data = user
      //Store data into cache
      cache.set(key, data)
    })
  }
  return data
}
```

## Step 4: Fetch User Data from the API

<TerminalInput>yarn add node-fetch</TerminalInput>

Create a function that retrives some user data

```js
async function getRandomUser() {
  let res = await fetch('https://randomuser.me/api/')
  let json = await res.json()
  return json
}
```

## Step 5: Create a `GET` route to fetch data from the cache

```js
app.get('/', (req, res) => {
  let result =
    getData('random_user') === undefined
      ? 'No Data in cache'
      : getData('random_user')
  res.status(200).json(result)
})
```

Let's say the cache key is `random_user`. By passing it to the `getData` function, when the key is available within the cache, it will return user data or fetch the necessary data from the API and cache it for the next request for data under the same key.

The complete setup will look like the following:

```js
const LRU = require('lru-cache')
const express = require('express')
const fetch = require('node-fetch')
const app = express()

const options = {
  max: 5, // The maximum number of items allowed in the cache
  maxAge: 15000 // The maximum life of a cached item in milliseconds
}

const cache = new LRU(options)

async function getRandomUser() {
  let res = await fetch('https://randomuser.me/api/')
  let json = await res.json()
  return json
}

function getData(key) {
  //Check if data is in the cache
  var data = cache.get(key)

  //When key is not present in cache data is undefined then fetch it again
  if (!data) {
    //Get a random user and set it to cache
    getRandomUser().then(user => {
      data = user
      //Store data into cache
      cache.set(key, data)
    })
  }
  return data
}

app.get('/', (req, res) => {
  let result =
    getData('random_user') === undefined
      ? 'No Data in cache'
      : getData('random_user')
  res.status(200).json(result)
})

module.exports = app
```

## Step 6: Deploying with Now

If you have not yet installed Now, you can do so by installing the [Now Desktop app](/docs/v2/getting-started/installation/#now-desktop) which installs Now CLI automatically, or by [installing Now CLI](/docs/v2/getting-started/installation/#now-cli) directly.

For the deployment to build and act as you would expect, you will need to create a [`now.json` configuration file](https://zeit.co/docs/v2/deployments/configuration) to instruct Now on how to handle your application in the build phase and when being served to visitors.

```json
{
  "version": 2,
  "name": "nodejs-lrucache-demo",
  "builds": [{ "src": "**/*.js", "use": "@now/node" }]
}
```

## Resources

To configure Now further, please see these additional topics and guides:

<Card title="Deploying Basics" href="/docs/v2/deployments/basics">
  Deploy any of your applications with ZEIT Now.
</Card>

<Card
  title="Aliasing"
  href="/docs/v2/domains-and-aliases/aliasing-a-deployment/"
>
  Learn more about aliasing to your deployments.
</Card>

<Card title="www. Redirect" href="/guides/redirect-from-www">
  Create a redirect from the www. subdomain to your naked domain.
</Card>

<Card title="More Guides" href="/guides">
  See more guides that help you move forward with your projects and deployments.
</Card>

export default ({ children }) => <Guide meta={meta}>{children}</Guide>
